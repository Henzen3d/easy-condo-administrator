// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = "https://lzlidefxxfoacoyfyaat.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx6bGlkZWZ4eGZvYWNveWZ5YWF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA2OTc1MzIsImV4cCI6MjA1NjI3MzUzMn0.s5k8WK6Q664AqwxnoXXTtShB09uHsbjRo0ujHmS7ggw";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Função para criar RPC para listar tabelas
export async function createTableListingFunction() {
  try {
    // Criar função para listar tabelas
    const getTablesSQL = `
      CREATE OR REPLACE FUNCTION get_tables()
      RETURNS TABLE (table_name text) 
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $$
      BEGIN
        RETURN QUERY 
        SELECT tablename::text FROM pg_catalog.pg_tables 
        WHERE schemaname = 'public';
      END;
      $$;
    `;
    
    const { error } = await supabase.rpc('exec_sql', { sql: getTablesSQL });
    
    if (error) {
      console.error('Erro ao criar função get_tables:', error);
      return false;
    }
    
    // Criar função para listar colunas
    const getColumnsSQL = `
      CREATE OR REPLACE FUNCTION get_columns(table_name text)
      RETURNS TABLE (column_name text, data_type text) 
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $$
      BEGIN
        RETURN QUERY 
        SELECT a.attname::text, pg_catalog.format_type(a.atttypid, a.atttypmod)::text
        FROM pg_catalog.pg_attribute a
        WHERE a.attrelid = ('public.' || table_name || '::regclass')::oid
        AND a.attnum > 0 
        AND NOT a.attisdropped;
      END;
      $$;
    `;
    
    const { error: columnsError } = await supabase.rpc('exec_sql', { sql: getColumnsSQL });
    
    if (columnsError) {
      console.error('Erro ao criar função get_columns:', columnsError);
      return false;
    }
    
    // Criar função para executar SQL
    const execSqlSQL = `
      CREATE OR REPLACE FUNCTION exec_sql(sql text)
      RETURNS void 
      LANGUAGE plpgsql
      SECURITY DEFINER
      AS $$
      BEGIN
        EXECUTE sql;
      END;
      $$;
    `;
    
    const { error: execSqlError } = await supabase.rpc('exec_sql', { sql: execSqlSQL });
    
    if (execSqlError && !execSqlError.message.includes('already exists')) {
      console.error('Erro ao criar função exec_sql:', execSqlError);
      return false;
    }
    
    return true;
  } catch (e) {
    console.error('Erro ao criar funções RPC:', e);
    return false;
  }
}

// Função para criar a tabela billings diretamente
export async function createBillingsTable() {
  try {
    console.log("Tentando criar tabela billings diretamente");
    
    // Primeiro, verificar se a tabela já existe
    const { data, error } = await supabase
      .from('pg_catalog.pg_tables')
      .select('tablename')
      .eq('schemaname', 'public')
      .eq('tablename', 'billings');
      
    if (data && data.length > 0) {
      console.log("A tabela billings já existe");
      return true;
    }
    
    // Criar a tabela usando SQL
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS billings (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        unit TEXT NOT NULL,
        unit_id INTEGER,
        resident TEXT,
        description TEXT NOT NULL,
        amount NUMERIC NOT NULL,
        due_date DATE NOT NULL,
        status TEXT DEFAULT 'pending',
        is_printed BOOLEAN DEFAULT false,
        is_sent BOOLEAN DEFAULT false,
        reference_month TEXT,
        reference_year TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
      );
    `;
    
    // Tentar criar a extensão uuid-ossp se não existir
    const createExtensionSQL = `
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    `;
    
    // Executar SQL através do endpoint de administração
    const createTableResponse = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        'Prefer': 'resolution=merge-duplicates'
      },
      body: JSON.stringify({
        query: createExtensionSQL + createTableSQL
      })
    });
    
    if (!createTableResponse.ok) {
      const responseText = await createTableResponse.text();
      console.error("Erro ao criar tabela billings:", responseText);
      return false;
    }
    
    console.log("Tabela billings criada com sucesso");
    return true;
  } catch (e) {
    console.error("Erro ao criar tabela billings:", e);
    return false;
  }
}

// Função para dropar a tabela billings e recriá-la
export async function dropAndRecreateBillingsTable() {
  try {
    console.log("Iniciando processo de exclusão e recriação da tabela billings");
    
    // SQL para dropar a tabela se existir e criar novamente
    const dropAndCreateSQL = `
      DROP TABLE IF EXISTS billings;
      
      CREATE TABLE billings (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        unit TEXT NOT NULL,
        unit_id INTEGER,
        resident TEXT,
        description TEXT NOT NULL,
        amount NUMERIC NOT NULL,
        due_date DATE NOT NULL,
        status TEXT DEFAULT 'pending',
        is_printed BOOLEAN DEFAULT false,
        is_sent BOOLEAN DEFAULT false,
        reference_month TEXT,
        reference_year TEXT,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
      );
      
      CREATE INDEX IF NOT EXISTS billings_unit_id_idx ON billings(unit_id);
      CREATE INDEX IF NOT EXISTS billings_status_idx ON billings(status);
      CREATE INDEX IF NOT EXISTS billings_due_date_idx ON billings(due_date);
    `;
    
    // Tentar criar a extensão uuid-ossp para gen_random_uuid()
    const createExtensionSQL = `
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    `;
    
    // Executar SQL através do endpoint de administração
    const dropRecreateResponse = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
        'Prefer': 'resolution=merge-duplicates'
      },
      body: JSON.stringify({
        query: createExtensionSQL + dropAndCreateSQL
      })
    });
    
    if (!dropRecreateResponse.ok) {
      const responseText = await dropRecreateResponse.text();
      console.error("Erro ao recriar tabela billings:", responseText);
      return { success: false, error: responseText };
    }
    
    console.log("Tabela billings recriada com sucesso");
    return { success: true };
  } catch (e) {
    console.error("Erro ao recriar tabela billings:", e);
    return { success: false, error: e };
  }
}

// Helper function to ensure tables exist
export async function ensureTablesExist() {
  try {
    // Tentar criar as funções RPC primeiro
    await createTableListingFunction();
    
    // Verificar se a tabela billings existe e criá-la se necessário
    const billingResult = await createBillingsTable();
    if (!billingResult) {
      console.error("Falha ao criar a tabela billings");
    }
    
    // Check if units table exists
    const { error: unitsError } = await supabase
      .from('units')
      .select('id')
      .limit(1);
      
    // If there's an error, the table might not exist (error code 'PGRST116')
    if (unitsError && unitsError.code === 'PGRST116') {
      console.warn('Units table might not exist');
      
      // Try to create the table - this requires appropriate permissions
      const createUnitsSQL = `
        CREATE TABLE IF NOT EXISTS units (
          id SERIAL PRIMARY KEY,
          number TEXT NOT NULL,
          block TEXT NOT NULL,
          owner TEXT NOT NULL,
          residents INTEGER DEFAULT 0,
          status TEXT DEFAULT 'occupied',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
          UNIQUE(number, block)
        );
      `;
      
      try {
        // Use RPC to execute SQL - note: this requires appropriate permissions
        const { error: createUnitsError } = await supabase.rpc('execute_sql', { sql: createUnitsSQL });
        
        if (createUnitsError) {
          console.error('Error creating units table:', createUnitsError);
        } else {
          console.log('Units table created successfully');
        }
      } catch (sqlError) {
        console.error('SQL execution error:', sqlError);
      }
    }
    
    // Check if residents table exists
    const { error: residentsError } = await supabase
      .from('residents')
      .select('id')
      .limit(1);
      
    // If there's an error, the table might not exist
    if (residentsError && residentsError.code === 'PGRST116') {
      console.warn('Residents table might not exist');
      
      // Try to create the table
      const createResidentsSQL = `
        CREATE TABLE IF NOT EXISTS residents (
          id SERIAL PRIMARY KEY,
          name TEXT NOT NULL,
          email TEXT,
          phone TEXT,
          unit_id INTEGER NOT NULL,
          role TEXT DEFAULT 'resident',
          status TEXT DEFAULT 'active',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
        );
      `;
      
      try {
        // Use RPC to execute SQL
        const { error: createResidentsError } = await supabase.rpc('execute_sql', { sql: createResidentsSQL });
        
        if (createResidentsError) {
          console.error('Error creating residents table:', createResidentsError);
        } else {
          console.log('Residents table created successfully');
        }
      } catch (sqlError) {
        console.error('SQL execution error:', sqlError);
      }
    }
    
    return true;
  } catch (error) {
    console.error('Error ensuring tables exist:', error);
    return false;
  }
}

// Export function to test connection and check table status
export async function checkSupabaseConnection() {
  try {
    // Test connection
    const { data, error } = await supabase.from('billings').select('count');
    
    if (error) {
      console.error("Error connecting to Supabase:", error);
      return {
        connected: false,
        error: error.message,
        tables: []
      };
    }
    
    // Método alternativo para listar tabelas usando pg_catalog
    const { data: tables, error: tablesError } = await supabase
      .from('pg_catalog.pg_tables')
      .select('tablename')
      .eq('schemaname', 'public');
      
    if (tablesError) {
      console.error("Error fetching tables:", tablesError);
      return {
        connected: true,
        error: tablesError.message,
        tables: []
      };
    }
    
    const tableNames = tables?.map(t => t.tablename) || [];
    
    return {
      connected: true,
      error: null,
      tables: tableNames
    };
  } catch (e) {
    console.error("Exception checking Supabase connection:", e);
    return {
      connected: false,
      error: e instanceof Error ? e.message : "Unknown error",
      tables: []
    };
  }
}
